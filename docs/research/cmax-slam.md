# CMax-SLAM: Event-Based Rotational Bundle Adjustment

## Executive Summary

CMax-SLAM (Contrast Maximization SLAM) is a rotation-only SLAM system that uses contrast maximization to estimate camera motion from event streams. Unlike our current CM pipeline which performs single-frame RPM estimation, CMax-SLAM provides continuous trajectory estimation through B-spline parameterization and sliding-window bundle adjustment.

**Key Insight for ebc-rs**: CMax-SLAM's approach could replace our current "SOBEL" edge detection in the top-right quadrant with a more principled motion-compensated panoramic map that naturally produces sharp edges when the correct rotation is found.

## Core Concepts

### 1. The Contrast Maximization Objective

The fundamental principle: events generated by the same physical edge at different times should align when warped with the correct motion parameters.

```
argmax_R(t) f(I(R(t); E))
```

Where:
- `R(t)` is the camera rotation trajectory
- `E` is the event stream
- `I` is the Image of Warped Events (IWE)
- `f` is a sharpness metric (variance)

**Variance as Sharpness**: High variance = events concentrated at edges = sharp image = correct motion estimate.

### 2. Event Warping

For each event `e_k = (x_k, y_k, t_k, p_k)`:

1. Convert pixel to 3D bearing vector: `X_k = K^{-1} * [x_k, y_k, 1]^T`
2. Apply rotation: `X'_k = R(t_k) * X_k`
3. Project to panoramic image (equirectangular): `(u, v) = proj(X'_k)`
4. Accumulate via bilinear voting (since projected coords may be non-integer)

### 3. B-Spline Trajectory Representation

Instead of discrete poses, CMax-SLAM models camera rotation as a continuous B-spline in SO(3):

- **Linear splines**: Interpolate between 2 adjacent control poses along geodesic paths
- **Cubic splines**: Use 4 neighboring control poses for smoother trajectories

**Benefits**:
- Continuous-time representation matches asynchronous event nature
- Jacobian sparsity: each event only affects a few control poses
- Natural smoothness constraints

### 4. System Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        CMax-SLAM                            │
├─────────────────────────────────────────────────────────────┤
│  FRONTEND                                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ - Constant-frequency event slicing                    │  │
│  │ - Per-slice angular velocity estimation via CMax      │  │
│  │ - Produces local IWEs                                 │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │                                │
│                            ▼                                │
│  BACKEND                                                    │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ - Sliding-window bundle adjustment                    │  │
│  │ - B-spline trajectory refinement                      │  │
│  │ - Produces global panoramic IWE                       │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## Key Algorithms

### Frontend: Angular Velocity Estimation

```
For each time window [t_start, t_end]:
    1. Slice events around reference time t_ref
    2. Initialize omega from previous estimate
    3. Optimize: argmax_omega Var(IWE(omega))
    4. Use Conjugate Gradient (Fletcher-Reeves) method
    5. Output: estimated angular velocity omega
```

### Backend: Bundle Adjustment

```
For sliding window of N segments:
    1. Initialize control poses from frontend estimates
    2. For each iteration:
        a. Warp all events to panoramic image
        b. Compute contrast (variance)
        c. Compute Jacobian w.r.t. control poses (sparse!)
        d. Update control poses via CG-FR
    3. Apply adaptive weighting to balance old/new events
```

### Optimization: Lift-Solve-Retract

Since rotations live in SO(3) (a Lie group), optimization follows:

1. **Lift**: Map to tangent space (so(3) - skew-symmetric matrices)
2. **Solve**: Linear system in tangent space for rotation increments
3. **Retract**: Apply increments back to SO(3) via exponential map

## Comparison with Current CM Pipeline

| Aspect | Current CM (ebc-rs) | CMax-SLAM |
|--------|---------------------|-----------|
| Motion Model | Fixed center rotation | General 3-DOF rotation |
| Trajectory | Discrete omega per window | Continuous B-spline |
| Optimization | Grid search over omega | Gradient-based (CG-FR) |
| Output | Single IWE per window | Panoramic map |
| Bundle Adjustment | No | Yes (sliding window) |
| Implementation | GPU (WGSL) | CPU (C++) |

## Relevance to ebc-rs Fan RPM Estimation

### What We Can Adopt

1. **Gradient-Based Optimization**: Replace our grid search with conjugate gradient
2. **Continuous Trajectories**: Model omega as smooth function, not discrete
3. **Adaptive Event Weighting**: Balance old/new events in accumulation
4. **Panoramic Mapping**: Build accumulated edge map over time

### What Differs for Our Use Case

1. **Fixed Rotation Center**: Fan has known/estimated centroid (simpler than general rotation)
2. **Periodic Motion**: Fan rotation is cyclic - can exploit periodicity
3. **GPU Acceleration**: We need real-time performance, CMax-SLAM runs on CPU
4. **RPM Focus**: We extract a scalar (RPM) not full trajectory

### Proposed Hybrid Approach

```
SOBEL Replacement Pipeline:
┌────────────────────────────────────────────────────────────┐
│  1. Use CM frontend for per-window omega estimation        │
│  2. Accumulate events with motion compensation             │
│  3. Build running panoramic map (polar coordinates)        │
│  4. Apply edge detection to motion-compensated map         │
│  5. Display as replacement for raw Sobel output            │
└────────────────────────────────────────────────────────────┘
```

## Mathematical Details

### Variance Objective Function

```
Var(I) = (1/N_pixels) * sum_i (I_i - mean(I))^2
```

For implementation, since `mean(I) = N_events / N_pixels` is constant:

```
Var(I) ~ sum_i I_i^2   (proportional, can skip mean subtraction)
```

### Rotation Matrix from Angular Velocity

For small time delta `dt` and angular velocity `omega`:

```
R(dt) = exp(omega_skew * dt)

where omega_skew = [  0    -omega_z  omega_y ]
                   [ omega_z   0    -omega_x ]
                   [-omega_y omega_x    0    ]
```

For 2D planar rotation (our case):
```
R(theta) = [ cos(theta)  -sin(theta) ]
           [ sin(theta)   cos(theta) ]

where theta = omega * dt
```

### Jacobian for Optimization

The gradient of variance w.r.t. omega:

```
dVar/d_omega = (2/N_p) * sum_i (I_i - mu) * dI_i/d_omega

dI_i/d_omega = sum_k b'(x'_k - x_i) * dx'_k/d_omega
```

Where `b'` is the derivative of the bilinear interpolation kernel.

## References

1. [CMax-SLAM Paper (arXiv)](https://arxiv.org/abs/2403.08119) - Full paper with mathematical derivations
2. [CMax-SLAM GitHub](https://github.com/tub-rip/cmax_slam) - Official C++ implementation
3. [Original CMax Framework](https://arxiv.org/abs/1804.01306) - Gallego et al. 2018, foundational work
4. [Basalt Headers](https://github.com/VladyslavUsenko/basalt-headers) - B-spline derivative computation

## Implementation Notes for ebc-rs

### GPU Considerations

CMax-SLAM runs on CPU, but for real-time performance in ebc-rs we need GPU acceleration:

1. **Warp Kernel**: Already implemented in `cm_warp.wgsl`
2. **Variance Computation**: Use parallel reduction (existing in `cm_contrast.wgsl`)
3. **Gradient Computation**: Need new shader for Jacobian computation
4. **Optimizer**: Keep on CPU (small problem, latency matters)

### Suggested Pipeline Stages

```wgsl
// Stage 1: Event Warping (existing)
@compute fn warp_events(...)

// Stage 2: IWE Accumulation (existing)
// Use atomic adds for bilinear voting

// Stage 3: Variance Computation (existing)
@compute fn compute_variance(...)

// Stage 4: Gradient Computation (NEW for CMax-SLAM approach)
@compute fn compute_gradient(...)  // dVar/d_omega

// Stage 5: Best Selection (existing)
@compute fn select_best(...)
```

### Configuration Parameters

From CMax-SLAM that we should consider:

- `contrast_threshold`: Minimum contrast for valid estimate
- `window_size`: Events to include in optimization
- `num_iterations`: Max optimizer iterations
- `spline_order`: 1 (linear) or 3 (cubic)
- `adaptive_weight_decay`: For balancing old/new events
