# CMax-SLAM Evaluation Framework

## Overview

This document describes how to evaluate the CMax-SLAM motion-compensated edge detection pipeline against ground truth data. The evaluation covers:

1. **Edge Detection Accuracy** - How well detected edges align with ground truth blade positions
2. **RPM Estimation Accuracy** - How close the estimated angular velocity is to ground truth RPM
3. **Blade Counting** - Whether the correct number of blades can be inferred from the IWE

## Current Workflow Review

### Existing Pipeline (`flake.nix`)

```
┌─────────────────────────────────────────────────────────────────────────┐
│  1. generate_data      Generate synthetic fan data with ground truth     │
│                        ↓                                                 │
│  2. compare_live       Live visualization comparing all detectors        │
│                        Shows: RAW | CMax-SLAM | CM | LoG                 │
│                        ↓                                                 │
│  3. optimise_params    Grid search over hyperparameters                  │
│                        Outputs: results/synthetic_search.csv             │
└─────────────────────────────────────────────────────────────────────────┘
```

### Ground Truth Data Structure

Generated by `generate_synthetic`:
- `fan_test.dat` - Binary event stream
- `fan_test_truth.json` - Ground truth parameters:
  ```json
  {
    "params": {
      "center_x": 640.0,      // Fan center X
      "center_y": 360.0,      // Fan center Y
      "radius_min": 50.0,     // Blade root radius
      "radius_max": 200.0,    // Blade tip radius
      "blade_count": 3,       // Number of blades
      "rpm": 1200.0,          // Ground truth RPM
      "sweep_k": 0.5,         // Logarithmic spiral parameter
      "width_root_rad": 0.5,  // Blade width at root (radians)
      "width_tip_rad": 0.3,   // Blade width at tip (radians)
      "edge_thickness_px": 2.0
    },
    "frames": [...]  // Per-frame edge pixel lists (optional)
  }
  ```

### Existing Metrics (`GroundTruthMetrics`)

Located in `src/ground_truth.rs`:

| Metric | Description |
|--------|-------------|
| `precision` | Exact: TP / (TP + FP) |
| `recall` | Exact: TP / (TP + FN) |
| `f1_score` | Exact: 2*P*R / (P+R) |
| `iou` | Intersection over Union |
| `tolerance_precision` | % detected edges within N px of GT |
| `tolerance_recall` | % GT edges within N px of detected |
| `tolerance_f1` | F1 using tolerance-based matching |
| `avg_distance` | Mean distance from GT to nearest detected |
| `median_distance` | Median distance from GT to nearest detected |

## Evaluation Plan

### Phase 1: Edge Detection Evaluation

#### 1.1 Metrics to Compute

For each detector (RAW, CMax-SLAM, CM, LoG):

```rust
struct EdgeEvaluationResult {
    // Core metrics (existing)
    tolerance_precision: f32,  // Target: > 80%
    tolerance_recall: f32,     // Target: > 70%
    tolerance_f1: f32,         // Target: > 75%
    avg_distance: f32,         // Target: < 3.0 px

    // New metrics for CMax-SLAM
    edge_sharpness: f32,       // IWE variance (higher = sharper)
    temporal_consistency: f32, // Frame-to-frame edge stability
}
```

#### 1.2 Test Conditions

Generate synthetic data with varying parameters:

| Parameter | Test Values | Purpose |
|-----------|-------------|---------|
| RPM | 600, 900, 1200, 1500, 2000 | Motion blur sensitivity |
| Blade count | 2, 3, 4, 5 | Edge density |
| Window size | 1000, 2500, 5000, 10000 μs | Temporal integration |
| Noise level | 0%, 5%, 10%, 20% | Robustness |

#### 1.3 Implementation Steps

1. **Extend `generate_synthetic`** to accept command-line parameters:
   ```bash
   generate_data --rpm 1200 --blades 3 --noise 0.05 --output data/synthetic/sweep_rpm1200_b3.dat
   ```

2. **Add batch evaluation binary** (`evaluate_detectors`):
   ```rust
   // src/bin/evaluate_detectors.rs
   fn main() {
       // Load data and ground truth
       // Run each detector
       // Compute metrics
       // Output CSV: rpm,blades,detector,precision,recall,f1,avg_dist
   }
   ```

3. **Add to `flake.nix`**:
   ```nix
   evaluate_cmax = {
     type = "app";
     program = toString (pkgs.writeShellScript "evaluate_cmax" ''
       ${envSetup}
       exec cargo run --release --bin evaluate_detectors -- \
         --data data/synthetic/fan_test.dat \
         --output results/cmax_evaluation.csv
     '');
   };
   ```

### Phase 2: RPM Estimation Evaluation

#### 2.1 Metrics

```rust
struct RpmEvaluationResult {
    ground_truth_rpm: f32,
    estimated_rpm: f32,

    // Error metrics
    absolute_error: f32,       // |estimated - GT|
    relative_error: f32,       // |estimated - GT| / GT

    // Confidence metrics
    contrast_score: f32,       // IWE variance at best omega
    peak_sharpness: f32,       // How distinct is the best omega

    // Temporal stability
    rpm_variance: f32,         // Variance over time window
    convergence_time: u32,     // Frames to reach stable estimate
}
```

#### 2.2 Comparison: CM vs CMax-SLAM

| Aspect | CM (Grid Search) | CMax-SLAM (Gradient) |
|--------|------------------|----------------------|
| Method | N discrete omega candidates | Continuous optimization |
| Speed | O(N * events) | O(iterations * events) |
| Precision | Limited by grid spacing | Limited by convergence |
| Initialization | Fixed range | Previous frame estimate |

#### 2.3 Implementation Steps

1. **Add RPM ground truth to `CmaxSlamState`**:
   ```rust
   pub struct CmaxSlamState {
       pub omega: f32,
       pub centroid: Vec2,
       pub contrast: f32,
       // New fields
       pub ground_truth_rpm: Option<f32>,
       pub rpm_error_history: Vec<f32>,
   }
   ```

2. **Add RPM logging to compare_live**:
   ```rust
   // In update system, log RPM estimates
   if let Some(gt_rpm) = gt_config.rpm {
       let estimated_rpm = state.omega.abs() * 60.0 / TAU * 1e6;
       info!("RPM: GT={:.1}, Est={:.1}, Error={:.1}%",
             gt_rpm, estimated_rpm,
             (estimated_rpm - gt_rpm).abs() / gt_rpm * 100.0);
   }
   ```

3. **Create RPM sweep test**:
   ```bash
   # Generate data at different RPMs
   for rpm in 600 900 1200 1500 2000; do
       generate_data --rpm $rpm --output data/synthetic/sweep_rpm${rpm}.dat
   done

   # Evaluate RPM estimation accuracy
   evaluate_rpm --data-dir data/synthetic/sweep_* --output results/rpm_accuracy.csv
   ```

### Phase 3: Blade Counting Evaluation

#### 3.1 Approach

With correct motion compensation, the IWE should show N distinct blade edges. We can count them by:

1. **Angular histogram**: Accumulate edge pixels in angular bins around centroid
2. **Peak detection**: Find local maxima in angular histogram
3. **Blade count = peaks / 2** (leading + trailing edges per blade)

#### 3.2 Implementation

```rust
/// Count blades from motion-compensated IWE
fn count_blades_from_iwe(
    iwe: &[f32],
    width: u32,
    height: u32,
    centroid: Vec2,
    radius_min: f32,
    radius_max: f32,
) -> u32 {
    // 1. Create angular histogram (360 bins)
    let mut angular_hist = vec![0.0f32; 360];

    for y in 0..height {
        for x in 0..width {
            let val = iwe[(y * width + x) as usize];
            if val <= 0.0 { continue; }

            let dx = x as f32 - centroid.x;
            let dy = y as f32 - centroid.y;
            let r = (dx*dx + dy*dy).sqrt();

            if r < radius_min || r > radius_max { continue; }

            let theta = dy.atan2(dx);
            let bin = ((theta + PI) / TAU * 360.0) as usize % 360;
            angular_hist[bin] += val;
        }
    }

    // 2. Smooth histogram
    let smoothed = gaussian_smooth(&angular_hist, 5);

    // 3. Find peaks (local maxima above threshold)
    let threshold = smoothed.iter().sum::<f32>() / 360.0 * 2.0;
    let peaks = find_peaks(&smoothed, threshold, 10); // min spacing = 10 bins

    // 4. Each blade has 2 edges (leading + trailing)
    (peaks.len() / 2) as u32
}
```

#### 3.3 Metrics

```rust
struct BladeCountResult {
    ground_truth_blades: u32,
    detected_blades: u32,
    correct: bool,

    // Confidence
    peak_prominence: f32,  // How clear are the peaks
    inter_peak_variance: f32,  // Regularity of blade spacing
}
```

### Phase 4: Comprehensive Evaluation Binary

#### 4.1 Output Format

```csv
# cmax_slam_evaluation.csv
timestamp,dataset,rpm_gt,rpm_est,rpm_error_pct,blades_gt,blades_det,blades_correct,precision,recall,f1,avg_dist,contrast,converged
1234567890,fan_rpm1200_b3,1200.0,1198.5,0.125,3,3,true,0.82,0.78,0.80,2.1,0.95,true
```

#### 4.2 Implementation

```rust
// src/bin/evaluate_cmax_slam.rs
use ebc_rs::{
    cmax_slam::{CmaxSlamParams, CmaxSlamState},
    ground_truth::{GroundTruthConfig, GroundTruthMetrics},
    synthesis::generate_fan_data_with_params,
};

fn main() -> Result<()> {
    let args = Args::parse();

    // Test matrix
    let rpm_values = vec![600.0, 900.0, 1200.0, 1500.0, 2000.0];
    let blade_counts = vec![2, 3, 4, 5];
    let window_sizes = vec![1000.0, 2500.0, 5000.0, 10000.0];

    let mut results = Vec::new();

    for rpm in &rpm_values {
        for blades in &blade_counts {
            for window in &window_sizes {
                // Generate test data
                let (events, gt_config) = generate_test_data(*rpm, *blades);

                // Run CMax-SLAM
                let cmax_result = run_cmax_slam(&events, &gt_config, *window);

                // Compute metrics
                let edge_metrics = compute_edge_metrics(&cmax_result.iwe, &gt_config);
                let rpm_metrics = compute_rpm_metrics(cmax_result.omega, *rpm);
                let blade_metrics = count_blades(&cmax_result.iwe, &gt_config);

                results.push(EvaluationResult {
                    rpm_gt: *rpm,
                    blades_gt: *blades,
                    window_size: *window,
                    edge_metrics,
                    rpm_metrics,
                    blade_metrics,
                });
            }
        }
    }

    // Write CSV
    write_results(&results, &args.output)?;

    // Print summary
    print_summary(&results);

    Ok(())
}
```

### Phase 5: Visualization Improvements

#### 5.1 Add Evaluation Overlay to compare_live

```rust
// In draw_metrics_overlay, add CMax-SLAM specific info
fn draw_cmax_slam_panel(ctx: &egui::Context, state: &CmaxSlamState, gt: &GroundTruthConfig) {
    egui::Window::new("CMax-SLAM Eval")
        .show(ctx, |ui| {
            let est_rpm = state.omega.abs() * 60.0 / TAU * 1e6;
            let rpm_error = if gt.rpm > 0.0 {
                (est_rpm - gt.rpm).abs() / gt.rpm * 100.0
            } else { 0.0 };

            ui.heading("CMax-SLAM");
            ui.separator();

            // RPM comparison
            ui.horizontal(|ui| {
                ui.label("RPM:");
                ui.label(egui::RichText::new(format!("{:.0}", est_rpm)).size(24.0).strong());
                if gt.rpm > 0.0 {
                    let color = if rpm_error < 1.0 {
                        egui::Color32::GREEN
                    } else if rpm_error < 5.0 {
                        egui::Color32::YELLOW
                    } else {
                        egui::Color32::RED
                    };
                    ui.label(egui::RichText::new(format!("({:.1}% err)", rpm_error)).color(color));
                }
            });

            // Ground truth reference
            if gt.rpm > 0.0 {
                ui.label(format!("GT RPM: {:.0}", gt.rpm));
                ui.label(format!("GT Blades: {}", gt.blade_count));
            }

            // Convergence status
            ui.label(format!("Converged: {}", state.converged));
            ui.label(format!("Contrast: {:.3}", state.contrast));
        });
}
```

#### 5.2 Add Ground Truth Overlay Toggle

Show ground truth blade edges overlaid on CMax-SLAM output:

```rust
// In composite shader or as separate overlay
if show_ground_truth_overlay {
    // Blend GT edges (green) with CMax-SLAM output
    let gt_edge = compute_gt_edge_at_time(coords, time);
    output = mix(output, vec4(0.0, 1.0, 0.0, 1.0), gt_edge * 0.5);
}
```

## Updated Workflow Commands

### `flake.nix` Additions

```nix
# Full evaluation sweep
evaluate_sweep = {
  type = "app";
  program = toString (pkgs.writeShellScript "evaluate_sweep" ''
    ${envSetup}

    # Generate test datasets
    for rpm in 600 900 1200 1500 2000; do
      for blades in 2 3 4 5; do
        cargo run --release --bin generate_synthetic -- \
          --rpm $rpm --blades $blades \
          --output "data/synthetic/sweep_rpm${rpm}_b${blades}.dat"
      done
    done

    # Run evaluation
    cargo run --release --bin evaluate_cmax_slam -- \
      --data-dir data/synthetic/sweep_* \
      --output results/cmax_slam_evaluation.csv

    echo "Results written to results/cmax_slam_evaluation.csv"
  '');
};

# Quick single-dataset evaluation
evaluate_quick = {
  type = "app";
  program = toString (pkgs.writeShellScript "evaluate_quick" ''
    ${envSetup}
    cargo run --release --bin evaluate_cmax_slam -- \
      --data data/synthetic/fan_test.dat \
      --output results/cmax_quick.csv
  '');
};
```

## Success Criteria

### Edge Detection
- **Tolerance F1 > 75%** for RPM 600-1500
- **Avg Distance < 3.0 px** for all conditions
- **Better than raw Sobel** in temporal consistency

### RPM Estimation
- **Relative Error < 5%** for steady-state rotation
- **Convergence within 100 frames** from cold start
- **Stable estimate** (variance < 2% over 1 second)

### Blade Counting
- **100% accuracy** for 2-4 blades at RPM 600-1200
- **> 90% accuracy** at higher RPM or more blades

## Implementation Priority

1. **[HIGH]** Add RPM error display to UI overlay
2. **[HIGH]** Create `evaluate_cmax_slam` binary with basic metrics
3. **[MEDIUM]** Extend `generate_synthetic` with CLI parameters
4. **[MEDIUM]** Implement blade counting from angular histogram
5. **[LOW]** Add ground truth overlay visualization
6. **[LOW]** Full parameter sweep automation

## References

- `src/ground_truth.rs` - Ground truth configuration and metrics
- `src/synthesis.rs` - Synthetic data generation
- `src/cmax_slam/` - CMax-SLAM pipeline implementation
- `docs/research/cmax-slam.md` - Algorithm background
